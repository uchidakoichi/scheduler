<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TeamSync | 共同スケジューラー</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --surface-color: #1e293b;
            --surface-hover: #334155;
            --primary-color: #6366f1;
            --primary-hover: #4f46e5;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --danger-color: #ef4444;
            --success-color: #10b981;
            --grid-border: rgba(255, 255, 255, 0.1);

            /* Category Colors */
            --cat-zen: #3b82f6;
            /* Blue - 全 */
            --cat-sei: #10b981;
            /* Green - 整 */
            --cat-toku: #a855f7;
            /* Purple - 特 */
            --cat-cho: #f97316;
            /* Orange - 調 */
            --cat-tou: #ef4444;
            /* Red - 当 */
            --cat-kyu: #64748b;
            /* Slate - 休 */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Hiragino Kaku Gothic ProN', 'Bisgiomar', 'Yu Gothic', 'Inter', system-ui, sans-serif;
            user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(16px);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
        }

        .brand {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: var(--surface-hover);
        }

        .btn.primary {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn.primary:hover {
            background: var(--primary-hover);
        }

        .btn.success {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--success-color);
            color: var(--success-color);
        }

        .btn-icon-only {
            padding: 0.5rem;
        }

        /* Filter Switcher */
        .filter-group {
            display: flex;
            gap: 0.5rem;
            padding: 4px;
            margin-right: 1rem;
            align-items: center;
        }

        .filter-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-right: 0.5rem;
        }

        .filter-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.3;
            transition: all 0.2s;
            border: 2px solid transparent;
            color: white;
        }

        .filter-btn.active {
            opacity: 1;
            transform: scale(1.1);
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        /* Status Bar */
        .status-indicator {
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }

        .dot.connected {
            background: var(--success-color);
            box-shadow: 0 0 8px var(--success-color);
        }

        .dot.syncing {
            background: var(--primary-color);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        /* --- Main Calendar --- */
        main {
            flex: 1;
            display: grid;
            grid-template-rows: auto 1fr;
            overflow: hidden;
            padding: 1rem;
            gap: 1rem;
            opacity: 0.5;
            pointer-events: none;
            /* Disabled until DB connected */
            transition: opacity 0.3s;
        }

        main.active {
            opacity: 1;
            pointer-events: all;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
        }

        .current-month {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: 40px repeat(auto-fill, minmax(100px, 1fr));
            border: 1px solid var(--grid-border);
            border-radius: 12px;
            background: var(--grid-border);
            /* Lines color */
            gap: 1px;
            /* The lines */
            overflow: hidden;
        }

        .weekday {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--surface-color);
            /* Need opaque bg */
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.875rem;
            /* Remove border-bottom */
        }

        .day-cell {
            /* Remove borders */
            background: var(--surface-color);
            /* Opaque cell bg */
            padding: 8px;
            min-height: 120px;
            position: relative;
            cursor: pointer;
            transition: background 0.1s;
        }



        .day-cell:hover {
            filter: brightness(1.2);
            /* Since bg is static, use filter or mix */
            background: var(--surface-hover);
        }

        .day-cell.other-month {
            background: var(--bg-color);
            /* Distinct dark bg */
            opacity: 1;
            /* Reset opacity since we use explicit color */
        }

        .day-cell:hover {
            background: var(--surface-hover);
        }

        .day-number {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            margin-left: 14px;
            /* Significantly increased */
            margin-top: 8px;
        }

        .day-cell.today .day-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .day-cell.other-month {
            background: rgba(0, 0, 0, 0.1);
            opacity: 0.5;
        }

        /* Events */
        .event-chip {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-bottom: 4px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: pointer;
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
        }

        .event-chip:hover {
            transform: scale(1.02);
            filter: brightness(1.1);
        }

        .event-writer {
            opacity: 0.8;
            font-size: 0.7em;
            background: rgba(0, 0, 0, 0.2);
            padding: 0 4px;
            border-radius: 2px;
        }

        /* --- Event Completed Style --- */
        .event-chip.completed {
            opacity: 0.6;
            text-decoration: line-through;
            border-style: dashed;
        }

        .event-chip.completed::after {
            content: "✓";
            margin-left: 4px;
            font-weight: bold;
        }

        /* --- Modal --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: none;
            place-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .modal-overlay.open {
            display: grid;
            opacity: 1;
        }

        .modal {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            width: 90%;
            max-width: 450px;
            padding: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
            transform: scale(0.95);
            transition: transform 0.2s;
        }

        .modal-overlay.open .modal {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        input,
        textarea,
        select {
            width: 100%;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem;
            color: white;
            outline: none;
            font-size: 1rem;
        }

        input:focus,
        textarea:focus {
            border-color: var(--primary-color);
        }

        /* Radio Group for Categories */
        .category-selector {
            display: flex;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            justify-content: space-around;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .radio-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid var(--text-secondary);
            position: relative;
        }

        input[type="radio"] {
            display: none;
        }

        input[type="radio"]:checked+.radio-circle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: white;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        /* User Management */
        .user-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
            padding: 4px;
        }

        .user-chip {
            background: var(--surface-hover);
            padding: 0.5rem;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
        }

        .user-chip .delete-btn {
            color: var(--danger-color);
            cursor: pointer;
            padding: 2px;
            margin-left: 4px;
        }

        /* Checkbox Grid for Writers */
        .writer-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.5rem;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .writer-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .writer-option input {
            width: auto;
            margin: 0;
        }

        /* Intro Barrier */
        .intro-barrier {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 5;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
        }

        .intro-barrier h2 {
            margin-bottom: 0.5rem;
        }

        .intro-barrier p {
            color: var(--text-secondary);
            max-width: 400px;
            margin: 0 auto;
        }

        /* Board View Styles */
        .board-view {
            display: none;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
            padding-right: 4px;
        }

        .board-view.active {
            display: flex;
        }

        .board-row {
            display: grid;
            grid-template-columns: 100px 1fr;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .board-user-label {
            background: var(--surface-color);
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-right: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .board-timeline {
            padding: 0.5rem;
            min-height: 80px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        /* View Switcher */
        .view-switcher {
            display: flex;
            background: var(--surface-color);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .view-btn {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.875rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .view-btn.active {
            background: var(--primary-color);
            color: white;
            font-weight: bold;
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                color: black;
                height: auto;
                overflow: visible;
                display: block;
            }

            /* Hide interactive/non-essential elements */
            header,
            .intro-barrier,
            .modal-overlay,
            .controls,
            .filter-group,
            .btn {
                display: none !important;
            }

            /* Helper: spacing for the month header */
            .calendar-header div[style*="width: 120px"] {
                display: none;
            }

            /* Main Layout */
            main {
                display: block !important;
                opacity: 1 !important;
                padding: 0;
                margin: 0;
            }

            .calendar-header {
                justify-content: center;
                margin: 0 0 1rem 0;
                padding: 0;
            }

            .current-month {
                color: black;
                font-size: 1.8rem;
                margin: 0;
            }

            /* Grid Bordering */
            .calendar-grid {
                border: 2px solid #000;
                background: transparent;
                gap: 0;
                display: grid;
                /* Maintain grid layout */
            }

            .weekday {
                background: #eee !important;
                /* Force light grey */
                color: black;
                border: 1px solid #000;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .day-cell {
                background: white !important;
                border: 1px solid #000;
                min-height: auto;
                /* Allow height to adjust */
                height: 100px;
                page-break-inside: avoid;
            }

            .day-cell.other-month {
                background: #f4f4f4 !important;
                opacity: 1;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* Event Styling */
            .event-chip {
                background: white !important;
                color: black !important;
                border: 1px solid #000;
                box-shadow: none;
                margin-bottom: 2px;
                padding: 1px 2px;
                font-size: 0.7rem;
            }

            /* Category Prefixes */
            .event-chip::before {
                font-weight: bold;
                margin-right: 2px;
            }

            .event-chip[data-category="cat_zen"]::before {
                content: "【全】";
            }

            .event-chip[data-category="cat_sei"]::before {
                content: "【整】";
            }

            .event-chip[data-category="cat_toku"]::before {
                content: "【特】";
            }

            .event-chip[data-category="cat_cho"]::before {
                content: "【調】";
            }

            .event-chip[data-category="cat_tou"]::before {
                content: "【当】";
            }

            .event-chip[data-category="cat_kyu"]::before {
                width: 3px;
                background: white;
                margin-right: 4px;
            }

            .day-cell.today .day-number {
                background: transparent;
                color: black;
                border: 2px solid black;
                width: 20px;
                height: 20px;
            }

            .day-number {
                color: black;
                margin-left: 4px;
                margin-top: 4px;
            }

            .event-writer {
                border: 1px solid #aaa;
                background: transparent;
                color: #333;
            }
        }
    </style>
</head>

<body>

    <header>
        <div class="brand">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="16" y1="2" x2="16" y2="6"></line>
                <line x1="8" y1="2" x2="8" y2="6"></line>
                <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            TeamSync <span style="font-size:0.8em; opacity:0.7; font-weight:normal;">共同スケジューラー</span>
        </div>

        <div class="controls">
            <div class="status-indicator">
                <div id="statusDot" class="dot"></div>
                <span id="statusText">未接続</span>
            </div>

            <div class="filter-group" id="filterGroup">
                <span class="filter-label">表示:</span>
                <!-- Injected by JS -->
            </div>

            <button class="btn" onclick="openUserModal()" id="btnUsers">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                    <circle cx="9" cy="7" r="4"></circle>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
                メンバー設定
            </button>
            <button class="btn primary" onclick="connectDatabase()" id="btnConnect">
                データファイルを選択 (共有)
            </button>
        </div>
    </header>

    <div class="intro-barrier" id="introBarrier">
        <h2>ファイルを選択して開始</h2>
        <p>共有フォルダ上のJSONファイルを選択（または作成）してください。<br>自動的に同期され、複数人での編集が可能になります。</p>
        <button class="btn primary" onclick="connectDatabase()"
            style="margin-top:1rem; font-size:1.1rem; padding: 0.8rem 1.5rem;">
            ファイルを開く / 新規作成
        </button>
    </div>

    <main id="mainContent">
        <div class="controls">
            <button class="btn btn-icon-only" onclick="navigateDate(-1)">&lt;</button>
            <button class="btn btn-icon-only" onclick="navigateDate(1)">&gt;</button>
            <button class="btn" onclick="goToToday()">今日</button>
        </div>
        <h2 class="current-month" id="monthLabel">2026年 1月</h2>
        <div class="view-switcher">
            <div class="view-btn active" onclick="switchView('month')" id="btnViewMonth">月</div>
            <div class="view-btn" onclick="switchView('day')" id="btnViewDay">日</div>
        </div>
        </div>

        <div class="calendar-grid" id="calendarGrid">
            <!-- Weekdays -->
            <div class="weekday">日</div>
            <div class="weekday">月</div>
            <div class="weekday">火</div>
            <div class="weekday">水</div>
            <div class="weekday">木</div>
            <div class="weekday">金</div>
            <div class="weekday">土</div>
            <!-- Days injected -->
        </div>

        <div class="board-view" id="boardView">
            <!-- Board injected -->
        </div>
    </main>

    <div class="modal-overlay" id="eventModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">予定を追加</h3>
                <button class="btn btn-icon-only" onclick="closeModal()"
                    style="border:none; background:none; font-size:1.5rem;">&times;</button>
            </div>
            <div class="form-group">
                <label>種別</label>
                <div class="category-selector" id="modalCategorySelector">
                    <!-- JS injected options -->
                </div>
            </div>
            <div class="form-group">
                <label>タイトル</label>
                <input type="text" id="eventTitle" placeholder="会議, 打ち合わせ等...">
            </div>
            <div class="form-group" style="display:grid; grid-template-columns: 1fr 1fr; gap:0.5rem;">
                <div>
                    <label>日付</label>
                    <input type="date" id="eventDate">
                </div>
                <div>
                    <label>時間</label>
                    <input type="time" id="eventTime">
                </div>
            </div>
            <div class="form-group">
                <label>氏名 (複数選択可)</label>
                <div class="writer-checkboxes" id="writerCheckboxes">
                    <!-- JS injected -->
                </div>
            </div>
            <div class="form-group">
                <label>詳細 / メモ</label>
                <textarea id="eventDesc" rows="3" placeholder="詳細を入力..."></textarea>
            </div>
            <div class="form-group" style="display:flex; align-items:center;">
                <label style="margin-bottom:0; cursor:pointer; display:flex; align-items:center; gap:0.5rem;">
                    <input type="checkbox" id="eventCompleted" style="width:20px; height:20px;">
                    <span>完了としてマーク</span>
                </label>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="deleteEvent()" id="btnDelete"
                    style="display:none; color: var(--danger-color); border-color:var(--danger-color);">削除</button>
                <button class="btn" onclick="closeModal()">キャンセル</button>
                <button class="btn primary" onclick="saveEvent()">保存</button>
            </div>
        </div>
    </div>

    <!-- User Management Modal -->
    <div class="modal-overlay" id="userModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">メンバー設定 (最大99名)</h3>
                <button class="btn btn-icon-only" onclick="closeUserModal()"
                    style="border:none; background:none; font-size:1.5rem;">&times;</button>
            </div>
            <div class="form-group">
                <div class="user-list" id="userListDisplay">
                    <!-- JS Injected -->
                </div>
            </div>
            <div class="form-group" style="display:flex; gap:0.5rem;">
                <input type="text" id="newUserName" placeholder="新しい氏名を入力...">
                <button class="btn primary" onclick="addUser()">追加</button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const CATEGORIES = [
            { id: 'cat_zen', name: '全', color: 'var(--cat-zen)' },
            { id: 'cat_sei', name: '整', color: 'var(--cat-sei)' },
            { id: 'cat_toku', name: '特', color: 'var(--cat-toku)' },
            { id: 'cat_cho', name: '調', color: 'var(--cat-cho)' },
            { id: 'cat_tou', name: '当', color: 'var(--cat-tou)' },
            { id: 'cat_kyu', name: '休', color: 'var(--cat-kyu)' },
        ];

        // --- State ---
        let state = {
            currentDate: new Date(),
            activeFilters: new Set(CATEGORIES.map(c => c.id)),
            users: [], // List of registered names
            events: [],
            viewMode: 'month', // 'month' or 'day'
            lastSelectedCategory: 'cat_zen',
            lastSelectedWriters: []
        };

        // --- Persistence Constants ---
        const PREF_LAST_CAT = 'lastSelectedCategory';
        const PREF_LAST_WRITERS = 'lastSelectedWriters';

        let fileHandle = null;
        let filePoller = null;
        let lastModifiedTime = 0;

        let editingEventId = null;

        // --- IndexedDB Manager ---
        const DB_NAME = 'TeamSyncDB';
        const STORE_NAME = 'prefs';
        let db = null;

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);

                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };

                request.onsuccess = (e) => {
                    db = e.target.result;
                    resolve(db);
                };

                request.onerror = (e) => reject(e);
            });
        }

        async function setPref(key, value) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                store.put(value, key);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject();
            });
        }

        async function getPref(key) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject();
            });
        }

        // --- Core Logic: Initialize ---

        async function init() {
            await initDB();

            // 1. Writer Name
            const search = window.location.search;
            let urlName = '';
            if (search) {
                if (search.startsWith("?name=")) urlName = decodeURIComponent(search.substring(6));
                else if (search.startsWith("?=")) urlName = decodeURIComponent(search.substring(2));
                else urlName = decodeURIComponent(search.substring(1));
            }

            if (urlName) {
                state.writerName = urlName;
                setPref('writerName', urlName);
            } else {
                const savedName = await getPref('writerName');
                if (savedName) state.writerName = savedName;
            }

            // 2. Filter Logic
            const savedFilters = await getPref('activeFilters');
            if (savedFilters && Array.isArray(savedFilters) && savedFilters.length > 0) {
                // Need to validate if saved filters exist in current CATEGORIES
                // If outdated IDs (like u1, cat_a) exist, they won't match, so fallback to all
                const validSaved = savedFilters.filter(id => CATEGORIES.some(c => c.id === id));
                if (validSaved.length > 0) {
                    state.activeFilters = new Set(validSaved);
                }
            }

            // 4. Persistence Load
            const savedLastCat = await getPref(PREF_LAST_CAT);
            if (savedLastCat) state.lastSelectedCategory = savedLastCat;

            const savedLastWriters = await getPref(PREF_LAST_WRITERS);
            if (savedLastWriters) state.lastSelectedWriters = savedLastWriters;

            // 5. Render
            renderFilters();
            renderModalSelector();
            renderCalendar();
            renderViewSwitcher();
        }

        // --- File System Access ---

        async function connectDatabase() {
            try {
                try {
                    [fileHandle] = await window.showOpenFilePicker({
                        types: [{ description: 'Scheduler Data JSON', accept: { 'application/json': ['.json'] } }],
                        multiple: false
                    });
                } catch (e) {
                    if (confirm("既存ファイルが見つかりませんか？新しいデータファイルを作成しますか？")) {
                        fileHandle = await window.showSaveFilePicker({
                            suggestedName: 'scheduler_data.json',
                            types: [{ description: 'Scheduler Data JSON', accept: { 'application/json': ['.json'] } }]
                        });
                        state.events = [];
                        await writeToFile(state.events);
                    } else {
                        return;
                    }
                }

                await loadFromFile();

                if (filePoller) clearInterval(filePoller);
                filePoller = setInterval(checkFileUpdates, 3000);

                document.getElementById('introBarrier').style.display = 'none';
                document.getElementById('mainContent').classList.add('active');
                document.getElementById('btnConnect').textContent = '接続済み: ' + fileHandle.name;
                document.getElementById('btnConnect').classList.add('success');
                document.getElementById('btnConnect').classList.remove('primary');
                updateStatus('接続完了', 'connected');

            } catch (err) {
                console.error(err);
                if (err.name !== 'AbortError') alert('接続エラー: ' + err.message);
            }
        }

        async function checkFileUpdates() {
            if (!fileHandle) return;
            try {
                const file = await fileHandle.getFile();
                if (file.lastModified > lastModifiedTime) {
                    updateStatus('同期中...', 'syncing');
                    const text = await file.text();
                    const json = JSON.parse(text);

                    if (json && json.events) {
                        state.events = json.events || [];
                        state.users = json.users || [];
                    } else {
                        // Fallback or init
                        state.events = [];
                        state.users = [];
                    }

                    lastModifiedTime = file.lastModified;
                    renderCalendar();
                    updateStatus('接続完了', 'connected');
                }
            } catch (err) {
                console.warn("Polling error", err);
                updateStatus('再接続中...', 'syncing');
            }
        }

        async function loadFromFile() {
            const file = await fileHandle.getFile();
            const text = await file.text();
            lastModifiedTime = file.lastModified;

            if (text) {
                try {
                    const json = JSON.parse(text);
                    state.events = json.events || [];
                    state.users = json.users || [];
                } catch (e) {
                    console.error("JSON Parse Error", e);
                    state.events = [];
                    state.users = [];
                }
            } else {
                state.events = [];
                state.users = [];
            }
            renderCalendar();
        }

        async function writeToFile(events) {
            if (!fileHandle) return;
            try {
                updateStatus('保存中...', 'syncing');
                const writable = await fileHandle.createWritable();
                // Save as object { users, events }
                const data = {
                    users: state.users,
                    events: events
                };
                await writable.write(JSON.stringify(data, null, 2));
                await writable.close();

                const file = await fileHandle.getFile();
                lastModifiedTime = file.lastModified;

                updateStatus('保存完了', 'connected');
            } catch (err) {
                alert('保存に失敗しました: ' + err.message);
                updateStatus('保存失敗', 'dot');
            }
        }

        async function saveTransaction(actionCallback) {
            if (!fileHandle) return;
            try {
                const file = await fileHandle.getFile();
                const text = await file.text();
                let currentData = text ? JSON.parse(text) : { users: [], events: [] };

                // Ensure structure
                if (!currentData.users) currentData.users = [];
                if (!currentData.events) currentData.events = [];

                // Update events
                const newEvents = actionCallback(currentData.events);

                // We also need to save the latest user list from state, because adding users is separate
                // But wait, user addition is also a transaction. 
                // Let's assume this specific function is for EVENT transaction.
                // However, let's just use state.users to ensure we don't lose them.
                // Better approach: allow callback to return full data or just events.
                // For safety, let's keep it simple: update events in the file, preserve users.

                const newData = {
                    users: state.users, // Use current state (synced)
                    events: newEvents
                };

                await writeToFile(newEvents); // This calls writeToFile which now expects data object logic? 
                // Wait, writeToFile takes 'events'. I changed writeToFile above to wrap it.
                // So I just pass newEvents to writeToFile.

                state.events = newEvents;
                renderCalendar();
            } catch (err) {
                alert("競合が発生したか、アクセスできませんでした。もう一度試してください。" + err.message);
            }
        }

        // --- UI Helpers ---

        function updateStatus(text, dotClass) {
            document.getElementById('statusText').textContent = text;
            document.getElementById('statusDot').className = 'dot ' + dotClass;
        }

        function renderFilters() {
            const container = document.getElementById('filterGroup');
            const btnsHtml = CATEGORIES.map(cat => `
            <div class="filter-btn ${state.activeFilters.has(cat.id) ? 'active' : ''}" 
                 style="background: ${cat.color}" 
                 onclick="toggleFilter('${cat.id}')"
                 title="${cat.name}を表示/非表示">
                ${cat.name}
            </div>
        `).join('');
            container.innerHTML = `<span class="filter-label">表示:</span>` + btnsHtml;
        }

        function toggleFilter(catId) {
            if (state.activeFilters.has(catId)) {
                state.activeFilters.delete(catId);
            } else {
                state.activeFilters.add(catId);
            }

            setPref('activeFilters', Array.from(state.activeFilters));
            renderFilters();
            renderCalendar();
        }

        function renderModalSelector() {
            const container = document.getElementById('modalCategorySelector');
            container.innerHTML = CATEGORIES.map((cat, idx) => `
            <label class="radio-option">
                <input type="radio" name="category" value="${cat.id}" ${idx === 0 ? 'checked' : ''}>
                <div class="radio-circle" style="border-color: ${cat.color}; background: ${cat.color}20"></div>
                ${cat.name}
            </label>
        `).join('');
        }

        function switchView(mode) {
            state.viewMode = mode;
            renderViewSwitcher();
            renderCalendar(); // Renders appropriate view
        }

        function renderViewSwitcher() {
            document.getElementById('btnViewMonth').className = `view-btn ${state.viewMode === 'month' ? 'active' : ''}`;
            document.getElementById('btnViewDay').className = `view-btn ${state.viewMode === 'day' ? 'active' : ''}`;
        }

        function navigateDate(delta) {
            if (state.viewMode === 'month') {
                state.currentDate.setMonth(state.currentDate.getMonth() + delta);
            } else {
                state.currentDate.setDate(state.currentDate.getDate() + delta);
            }
            renderCalendar();
        }

        function renderCalendar() {
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            const date = state.currentDate.getDate();

            if (state.viewMode === 'month') {
                document.getElementById('calendarGrid').style.display = 'grid';
                document.getElementById('boardView').classList.remove('active');
                document.getElementById('monthLabel').textContent = `${year}年 ${month + 1}月`;
                renderMonthView();
            } else {
                document.getElementById('calendarGrid').style.display = 'none';
                document.getElementById('boardView').classList.add('active');
                document.getElementById('monthLabel').textContent = `${year}年 ${month + 1}月 ${date}日`;
                renderBoardView();
            }
        }

        function renderMonthView() {
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDayIndex = firstDay.getDay();
            const totalDays = lastDay.getDate();
            const grid = document.getElementById('calendarGrid');
            const headers = Array.from(grid.children).slice(0, 7);
            grid.innerHTML = '';
            headers.forEach(h => grid.appendChild(h));
            const prevMonthLastDay = new Date(year, month, 0).getDate();
            for (let i = startDayIndex - 1; i >= 0; i--) {
                grid.innerHTML += createDayHTML(prevMonthLastDay - i, true);
            }
            const today = new Date();
            for (let i = 1; i <= totalDays; i++) {
                const isToday = i === today.getDate() && month === today.getMonth() && year === today.getFullYear();
                const dayDateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                grid.innerHTML += createDayHTML(i, false, isToday, dayDateStr);
            }
            const remaining = 42 - (startDayIndex + totalDays);
            for (let i = 1; i <= remaining; i++) {
                grid.innerHTML += createDayHTML(i, true);
            }
        }

        function renderBoardView() {
            const container = document.getElementById('boardView');
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            const day = state.currentDate.getDate();
            const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

            // Get events for today, filtered
            const dayEvents = state.events.filter(e => {
                let catId = resolveCategoryId(e);
                return e.date === dateStr && state.activeFilters.has(catId);
            });
            dayEvents.sort((a, b) => a.time.localeCompare(b.time));

            // Group by User
            // Events can have multiple writers (e.writers) or single (e.writer)
            // If e.writers has ['A', 'B'], show in both A and B rows.
            // If empty, show in Unassigned.

            const userMap = new Map();
            state.users.forEach(u => userMap.set(u, []));
            const unassigned = [];

            dayEvents.forEach(e => {
                let assigned = false;
                const writers = e.writers || (e.writer ? [e.writer] : []);
                if (writers.length > 0) {
                    writers.forEach(w => {
                        if (userMap.has(w)) {
                            userMap.get(w).push(e);
                            assigned = true;
                        }
                    });
                    // If writers exist but not in registry (deleted users), treat as unassigned or legacy? 
                    // Let's assume legacy names just don't appear in rows unless we add 'Others'.
                    // For now, only registered users get rows.
                }
                if (!assigned && writers.length === 0) {
                    unassigned.push(e);
                }
            });

            let html = '';

            // Render User Rows
            state.users.forEach(u => {
                const events = userMap.get(u);
                const eventHtml = events.map(e => createEventChip(e, true)).join('');
                html += `
                <div class="board-row">
                    <div class="board-user-label">${escapeHtml(u)}</div>
                    <div class="board-timeline" onclick="openAddModal('${dateStr}', ['${escapeHtml(u)}'])">
                        ${eventHtml}
                    </div>
                </div>`;
            });

            // Render Unassigned
            if (unassigned.length > 0) {
                const eventHtml = unassigned.map(e => createEventChip(e, true)).join('');
                html += `
                <div class="board-row">
                    <div class="board-user-label" style="font-style:italic;">未割り当て</div>
                    <div class="board-timeline" onclick="openAddModal('${dateStr}')">
                        ${eventHtml}
                    </div>
                </div>`;
            } else if (state.users.length === 0) {
                html = `<div style="padding:2rem; text-align:center; color:#aaa;">メンバーが登録されていません。<br>「メンバー設定」から追加してください。</div>`;
            }

            container.innerHTML = html;
        }

        // Refactored Event Chip Creation
        function createEventChip(e, showTime = false) {
            let catId = resolveCategoryId(e);
            const cat = CATEGORIES.find(c => c.id === catId) || CATEGORIES[0];
            let writersStr = '';

            if (e.writers && Array.isArray(e.writers)) writersStr = e.writers.join(', ');

            const writerHtml = (writersStr && !showTime) ? `<span class="event-writer">${escapeHtml(writersStr)}</span>` : '';
            const completedClass = e.completed ? 'completed' : '';

            return `
                <div class="event-chip ${completedClass}" 
                        data-category="${cat.id}"
                        style="background: ${cat.color}"
                        onclick="openEditModal('${e.id}', event)">
                        <span style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                        ${e.time} ${escapeHtml(e.title)}
                        </span>
                        ${writerHtml}
                </div>
            `;
        }

        function createDayHTML(dayNum, isGrey, isToday = false, dateStr = '') {
            let eventsHTML = '';

            if (!isGrey && dateStr) {
                const dayEvents = state.events.filter(e => {
                    let catId = resolveCategoryId(e);
                    return e.date === dateStr && state.activeFilters.has(catId);
                });

                dayEvents.sort((a, b) => a.time.localeCompare(b.time));

                dayEvents.forEach(e => {
                    eventsHTML += createEventChip(e);
                });
            }

            return `
            <div class="day-cell ${isGrey ? 'other-month' : ''} ${isToday ? 'today' : ''}"
                 ${!isGrey ? `onclick="openAddModal('${dateStr}')"` : ''}>
                <div class="day-number">${dayNum}</div>
                <div class="events-stack">${eventsHTML}</div>
            </div>
        `;
        }

        // Helper to map old IDs to new ones
        function resolveCategoryId(evt) {
            let raw = evt.categoryId || evt.userId;

            // If it's a valid ID, return it
            if (CATEGORIES.some(c => c.id === raw)) return raw;

            // Fallback
            return 'cat_zen';
        }

        // --- Modal Actions ---

        function openAddModal(dateStr, preselectedWriters = []) {
            if (!fileHandle) { alert("まずは「データファイルを選択」してください。"); return; }

            editingEventId = null;
            document.getElementById('modalTitle').textContent = '予定を追加';
            document.getElementById('eventTitle').value = '';
            document.getElementById('eventDate').value = dateStr;
            document.getElementById('eventTime').value = '';
            document.getElementById('eventDesc').value = '';
            document.getElementById('eventCompleted').checked = false;

            // Logic for default writers:
            // 1. If preselected (from board view click), use those.
            // 2. Else use Saved Preferences.
            let defaults = [];
            if (preselectedWriters.length > 0) {
                defaults = preselectedWriters;
            } else {
                defaults = state.lastSelectedWriters || [];
            }
            renderWriterCheckboxes(defaults);

            // Logic for default category
            const defCat = state.lastSelectedCategory || 'cat_zen';
            const radio = document.querySelector(`input[name="category"][value="${defCat}"]`);
            if (radio) radio.checked = true;

            document.getElementById('btnDelete').style.display = 'none';
            document.getElementById('eventModal').classList.add('open');
            setTimeout(() => document.getElementById('eventTitle').focus(), 100);
        }

        function openEditModal(evtId, e) {
            e.stopPropagation();
            const evt = state.events.find(x => x.id === evtId);
            if (!evt) return;

            editingEventId = evtId;
            document.getElementById('modalTitle').textContent = '予定を編集';
            document.getElementById('eventTitle').value = evt.title;
            document.getElementById('eventDate').value = evt.date;
            document.getElementById('eventTime').value = evt.time;
            document.getElementById('eventDesc').value = evt.desc;
            document.getElementById('eventCompleted').checked = !!evt.completed;

            // Checkboxes
            const currentWriters = evt.writers || (evt.writer ? [evt.writer] : []);
            renderWriterCheckboxes(currentWriters);

            const catId = resolveCategoryId(evt);
            const radio = document.querySelector(`input[name="category"][value="${catId}"]`) || document.querySelector('input[name="category"][value="cat_zen"]');
            if (radio) radio.checked = true;

            document.getElementById('btnDelete').style.display = 'block';
            document.getElementById('eventModal').classList.add('open');
        }

        function closeModal() {
            document.getElementById('eventModal').classList.remove('open');
        }

        async function saveEvent() {
            const title = document.getElementById('eventTitle').value;
            const date = document.getElementById('eventDate').value;
            const time = document.getElementById('eventTime').value;
            const desc = document.getElementById('eventDesc').value;
            const completed = document.getElementById('eventCompleted').checked;

            // Collect writers
            const checkboxes = document.querySelectorAll('#writerCheckboxes input:checked');
            const writers = Array.from(checkboxes).map(cb => cb.value);

            const categoryId = document.querySelector('input[name="category"]:checked').value;

            if (!title || !date) { alert('必須項目がありません'); return; }

            // Save Preferences
            setPref(PREF_LAST_CAT, categoryId);
            state.lastSelectedCategory = categoryId;
            setPref(PREF_LAST_WRITERS, writers);
            state.lastSelectedWriters = writers;

            closeModal();

            await saveTransaction((events) => {
                const eventData = {
                    title, date, time, desc, writers, categoryId, completed
                };

                if (editingEventId) {
                    // Update
                    return events.map(e => e.id === editingEventId ? {
                        ...e, ...eventData, updatedAt: Date.now()
                    } : e);
                } else {
                    // Create
                    const newEvent = {
                        id: Date.now().toString(36) + Math.random().toString(36).substr(2),
                        ...eventData,
                        createdAt: Date.now()
                    };
                    return [...events, newEvent];
                }
            });
        }

        // --- User Management Logic ---
        function openUserModal() {
            renderUserList();
            document.getElementById('userModal').classList.add('open');
            setTimeout(() => document.getElementById('newUserName').focus(), 100);
        }

        function closeUserModal() {
            document.getElementById('userModal').classList.remove('open');
        }

        function renderUserList() {
            const container = document.getElementById('userListDisplay');
            container.innerHTML = state.users.map((name, idx) => `
                <div class="user-chip">
                    ${escapeHtml(name)}
                    <span class="delete-btn" onclick="deleteUser(${idx})">&times;</span>
                </div>
             `).join('');
        }

        async function addUser() {
            const input = document.getElementById('newUserName');
            const name = input.value.trim();
            if (!name) return;

            if (state.users.length >= 99) {
                alert('登録人数が上限(99人)に達しています。');
                return;
            }
            if (state.users.includes(name)) {
                alert('既に登録されています。');
                return;
            }

            state.users.push(name);
            input.value = '';
            renderUserList();

            // Save immediately
            if (fileHandle) {
                // For user updates, we re-read file to avoid event overwrites, 
                // but simpler to just write full object with current events.
                try {
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    let json = text ? JSON.parse(text) : { users: [], events: [] };
                    if (Array.isArray(json)) json = { users: [], events: json };

                    json.users = state.users;

                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(json, null, 2));
                    await writable.close();
                } catch (e) {
                    console.error(e);
                    alert('保存できませんでした');
                }
            }
        }

        async function deleteUser(idx) {
            if (!confirm('このメンバーを削除しますか？')) return;
            state.users.splice(idx, 1);
            renderUserList();
            // Save immediately
            if (fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    let json = text ? JSON.parse(text) : { users: [], events: [] };
                    if (Array.isArray(json)) json = { users: [], events: json };

                    json.users = state.users;

                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(json, null, 2));
                    await writable.close();
                } catch (e) {
                    console.error(e);
                }
            }
        }

        function renderWriterCheckboxes(selectedWriters) {
            const container = document.getElementById('writerCheckboxes');
            if (state.users.length === 0) {
                container.innerHTML = '<span style="color:#aaa; font-size:0.8rem;">メンバーが登録されていません。<br>「メンバー設定」から追加してください。</span>';
                return;
            }

            container.innerHTML = state.users.map(u => {
                const isChecked = selectedWriters.includes(u);
                return `
                <label class="writer-option">
                    <input type="checkbox" value="${escapeHtml(u)}" ${isChecked ? 'checked' : ''}>
                    ${escapeHtml(u)}
                </label>
            `;
            }).join('');
        }

        async function deleteEvent() {
            if (!confirm('削除しますか？')) return;
            closeModal();
            await saveTransaction((events) => {
                return events.filter(e => e.id !== editingEventId);
            });
        }

        function changeMonth(delta) {
            state.currentDate.setMonth(state.currentDate.getMonth() + delta);
            renderCalendar();
        }

        function goToToday() {
            state.currentDate = new Date();
            renderCalendar();
        }

        function escapeHtml(text) {
            if (!text) return '';
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        // Boot
        init();

    </script>
</body>

</html>