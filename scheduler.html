<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TeamSync | ÂÖ±Âêå„Çπ„Ç±„Ç∏„É•„Éº„É©„Éº</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --surface-color: #1e293b;
            --surface-hover: #334155;
            --primary-color: #6366f1;
            --primary-hover: #4f46e5;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: #334155;
            --danger-color: #ef4444;
            --success-color: #10b981;
            --grid-border: rgba(255, 255, 255, 0.1);

            /* Category Colors */
            --cat-zen: #3b82f6;
            /* Blue - ÂÖ® */
            --cat-sei: #10b981;
            /* Green - Êï¥ */
            --cat-toku: #a855f7;
            /* Purple - Áâπ */
            --cat-cho: #f97316;
            /* Orange - Ë™ø */
            --cat-tou: #ef4444;
            /* Red - ÂΩì */
            --cat-kyu: #64748b;
            /* Slate - ‰ºë */
            --cat-private: #d8b4fe;
            /* Purple Stripe - Áßò */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Hiragino Kaku Gothic ProN', 'Bisgiomar', 'Yu Gothic', 'Inter', system-ui, sans-serif;
            user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(16px);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
        }

        .brand {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .btn {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: var(--surface-hover);
        }

        .btn.primary {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn.primary:hover {
            background: var(--primary-hover);
        }

        .btn.success {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--success-color);
            color: var(--success-color);
        }

        .btn-icon-only {
            padding: 0.5rem;
        }

        /* Filter Switcher */
        .filter-group {
            display: flex;
            gap: 0.5rem;
            padding: 4px;
            margin-right: 1rem;
            align-items: center;
        }

        .filter-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-right: 0.5rem;
        }

        .filter-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.3;
            transition: all 0.2s;
            border: 2px solid transparent;
            color: white;
        }

        .filter-btn.active {
            opacity: 1;
            transform: scale(1.1);
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        /* Status Bar */
        .status-indicator {
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }

        .dot.connected {
            background: var(--success-color);
            box-shadow: 0 0 8px var(--success-color);
        }

        .dot.syncing {
            background: var(--primary-color);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        /* --- Main Calendar --- */
        main {
            flex: 1;
            display: grid;
            grid-template-rows: auto 1fr;
            overflow: hidden;
            padding: 1rem;
            gap: 1rem;
            opacity: 0.5;
            pointer-events: none;
            /* Disabled until DB connected */
            transition: opacity 0.3s;
        }

        main.active {
            opacity: 1;
            pointer-events: all;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 1rem;
        }

        .current-month {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: 40px repeat(auto-fill, minmax(100px, 1fr));
            border: 1px solid var(--grid-border);
            border-radius: 12px;
            background: var(--grid-border);
            /* Lines color */
            gap: 1px;
            /* The lines */
            overflow: hidden;
        }

        .weekday {
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--surface-color);
            /* Need opaque bg */
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.875rem;
            /* Remove border-bottom */
        }

        .day-cell {
            /* Remove borders */
            background: var(--surface-color);
            /* Opaque cell bg */
            padding: 8px;
            min-height: 120px;
            position: relative;
            cursor: pointer;
            transition: background 0.1s;
        }



        .day-cell:hover {
            filter: brightness(1.2);
            /* Since bg is static, use filter or mix */
            background: var(--surface-hover);
        }

        .day-cell.other-month {
            background: var(--bg-color);
            /* Distinct dark bg */
            opacity: 1;
            /* Reset opacity since we use explicit color */
        }

        .day-cell:hover {
            background: var(--surface-hover);
        }

        .day-number {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            margin-left: 14px;
            /* Significantly increased */
            margin-top: 8px;
        }

        .day-cell.today .day-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .day-cell.other-month {
            background: rgba(0, 0, 0, 0.1);
            opacity: 0.5;
        }

        /* Events */
        .event-chip {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-bottom: 4px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: pointer;
            color: white;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 4px;
        }

        .event-chip:hover {
            transform: scale(1.02);
            filter: brightness(1.1);
        }

        .event-writer {
            opacity: 0.8;
            font-size: 0.7em;
            background: rgba(0, 0, 0, 0.2);
            padding: 0 4px;
            border-radius: 2px;
        }

        /* --- Event Completed Style --- */
        .event-chip.completed {
            opacity: 0.6;
            text-decoration: line-through;
            border-style: dashed;
        }

        .event-chip.completed::after {
            content: "‚úì";
            margin-left: 4px;
            font-weight: bold;
        }

        /* --- Modal --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            display: none;
            place-items: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .modal-overlay.open {
            display: grid;
            opacity: 1;
        }

        .modal {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            width: 95%;
            max-width: 600px;
            /* Wider */
            max-height: 90vh;
            /* Allow tall modal */
            padding: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
            transform: scale(0.95);
            transition: transform 0.2s;
            display: flex;
            /* Flex layout to handle scrolling inside */
            flex-direction: column;
        }

        .modal-overlay.open .modal {
            transform: scale(1);
        }

        .modal-header {
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        /* User Management */
        .user-list {
            display: flex;
            flex-direction: column;
            /* 1 person per row */
            gap: 0.5rem;

            /* Target: 20 rows. 
               If 1 row is approx 40px: 20 * 40 = 800px.
               Use vh to be safe, but set min-height or explicit height if screen allows.
            */
            height: 60vh;
            min-height: 400px;
            overflow-y: auto;
            margin-bottom: 1rem;
            padding: 4px;
            border: 1px solid var(--border-color);
            /* Add border for list area */
            border-radius: 8px;
        }

        .user-chip {
            background: var(--surface-hover);
            padding: 0.75rem 1rem;
            /* Larger touch area */
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1rem;
            /* Larger text */
        }

        .user-chip .delete-btn {
            color: var(--danger-color);
            cursor: pointer;
            padding: 2px;
            margin-left: 4px;
        }

        /* Checkbox Grid for Writers */
        .writer-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.5rem;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            padding: 0.5rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .writer-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .writer-option input {
            width: auto;
            margin: 0;
        }

        /* Intro Barrier */
        .intro-barrier {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 5;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
        }

        .intro-barrier h2 {
            margin-bottom: 0.5rem;
        }

        .intro-barrier p {
            color: var(--text-secondary);
            max-width: 400px;
            margin: 0 auto;
        }

        /* Board View Styles */
        .board-view {
            display: none;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
            padding-right: 4px;
        }

        .board-view.active {
            display: flex;
        }

        .board-row {
            display: grid;
            grid-template-columns: 100px 1fr;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .board-user-label {
            background: var(--surface-color);
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-right: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .board-timeline {
            padding: 0.5rem;
            min-height: 80px;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        /* View Switcher */
        .view-switcher {
            display: flex;
            background: var(--surface-color);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .view-btn {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.875rem;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .view-btn.active {
            background: var(--primary-color);
            color: white;
            font-weight: bold;
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
                color: black;
                height: auto;
                overflow: visible;
                display: block;
            }

            /* Hide interactive/non-essential elements */
            header,
            .intro-barrier,
            .modal-overlay,
            .controls,
            .filter-group,
            .btn {
                display: none !important;
            }

            /* Helper: spacing for the month header */
            .calendar-header div[style*="width: 120px"] {
                display: none;
            }

            /* Main Layout */
            main {
                display: block !important;
                opacity: 1 !important;
                padding: 0;
                margin: 0;
            }

            .calendar-header {
                justify-content: center;
                margin: 0 0 1rem 0;
                padding: 0;
            }

            .current-month {
                color: black;
                font-size: 1.8rem;
                margin: 0;
            }

            /* Grid Bordering */
            .calendar-grid {
                border: 2px solid #000;
                background: transparent;
                gap: 0;
                display: grid;
                /* Maintain grid layout */
            }

            .weekday {
                background: #eee !important;
                /* Force light grey */
                color: black;
                border: 1px solid #000;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .day-cell {
                background: white !important;
                border: 1px solid #000;
                min-height: auto;
                /* Allow height to adjust */
                height: 100px;
                page-break-inside: avoid;
            }

            .day-cell.other-month {
                background: #f4f4f4 !important;
                opacity: 1;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* Event Styling */
            .event-chip {
                background: white !important;
                color: black !important;
                border: 1px solid #000;
                box-shadow: none;
                margin-bottom: 2px;
                padding: 1px 2px;
                font-size: 0.7rem;
            }

            /* Category Prefixes */
            .event-chip::before {
                font-weight: bold;
                margin-right: 2px;
            }

            .event-chip[data-category="cat_zen"]::before {
                content: "„ÄêÂÖ®„Äë";
            }

            .event-chip[data-category="cat_sei"]::before {
                content: "„ÄêÊï¥„Äë";
            }

            .event-chip[data-category="cat_toku"]::before {
                content: "„ÄêÁâπ„Äë";
            }

            .event-chip[data-category="cat_cho"]::before {
                content: "„ÄêË™ø„Äë";
            }

            .event-chip[data-category="cat_private"]::before {
                content: "üîí";
                margin-right: 4px;
            }

            .event-chip[data-category="cat_private"] {
                background: repeating-linear-gradient(45deg, #d8b4fe, #d8b4fe 10px, #c084fc 10px, #c084fc 20px);
            }

            .event-chip[data-category="cat_tou"]::before {
                content: "„ÄêÂΩì„Äë";
            }

            .event-chip[data-category="cat_kyu"]::before {
                width: 3px;
                background: white;
                margin-right: 4px;
            }

            .event-chip.completed {
                opacity: 0.6;
                text-decoration: line-through;
            }

            .day-cell.today .day-number {
                background: transparent;
                color: black;
                border: 2px solid black;
                width: 20px;
                height: 20px;
            }

            .day-number {
                color: black;
                margin-left: 4px;
                margin-top: 4px;
            }

            .event-writer {
                border: 1px solid #aaa;
                background: transparent;
                color: #333;
            }
        }
    </style>
</head>

<body>

    <header>
        <div class="brand">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="16" y1="2" x2="16" y2="6"></line>
                <line x1="8" y1="2" x2="8" y2="6"></line>
                <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            TeamSync <span style="font-size:0.8em; opacity:0.7; font-weight:normal;">ÂÖ±Âêå„Çπ„Ç±„Ç∏„É•„Éº„É©„Éº</span>
        </div>

        <div class="controls">
            <div class="status-indicator">
                <div id="statusDot" class="dot"></div>
                <span id="statusText">Êú™Êé•Á∂ö</span>
            </div>

            <div class="filter-group" id="filterGroup">
                <span class="filter-label">Ë°®Á§∫:</span>
                <!-- Injected by JS -->
            </div>

            <button class="btn" onclick="openUserModal()" id="btnUsers">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                    <circle cx="9" cy="7" r="4"></circle>
                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                    <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
                „É°„É≥„Éê„ÉºË®≠ÂÆö
            </button>
            <button class="btn primary" onclick="connectDatabase()" id="btnConnect">
                „Éá„Éº„Çø„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû (ÂÖ±Êúâ)
            </button>
        </div>
    </header>

    <div class="intro-barrier" id="introBarrier">
        <h2>„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶ÈñãÂßã</h2>
        <p>ÂÖ±Êúâ„Éï„Ç©„É´„ÉÄ‰∏ä„ÅÆJSON„Éï„Ç°„Ç§„É´„ÇíÈÅ∏ÊäûÔºà„Åæ„Åü„ÅØ‰ΩúÊàêÔºâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ<br>Ëá™ÂãïÁöÑ„Å´ÂêåÊúü„Åï„Çå„ÄÅË§áÊï∞‰∫∫„Åß„ÅÆÁ∑®ÈõÜ„ÅåÂèØËÉΩ„Å´„Å™„Çä„Åæ„Åô„ÄÇ</p>
        <button class="btn primary" onclick="connectDatabase()"
            style="margin-top:1rem; font-size:1.1rem; padding: 0.8rem 1.5rem;">
            „Éï„Ç°„Ç§„É´„ÇíÈñã„Åè / Êñ∞Ë¶è‰ΩúÊàê
        </button>
    </div>

    <main id="mainContent">
        <div class="controls">
            <button class="btn btn-icon-only" onclick="navigateDate(-1)">&lt;</button>
            <button class="btn btn-icon-only" onclick="navigateDate(1)">&gt;</button>
            <button class="btn" onclick="goToToday()">‰ªäÊó•</button>
        </div>
        <h2 class="current-month" id="monthLabel">2026Âπ¥ 1Êúà</h2>
        <div class="view-switcher">
            <div class="view-btn active" onclick="switchView('month')" id="btnViewMonth">Êúà</div>
            <div class="view-btn" onclick="switchView('day')" id="btnViewDay">Êó•</div>
        </div>
        </div>

        <div class="calendar-grid" id="calendarGrid">
            <!-- Weekdays -->
            <div class="weekday">Êó•</div>
            <div class="weekday">Êúà</div>
            <div class="weekday">ÁÅ´</div>
            <div class="weekday">Ê∞¥</div>
            <div class="weekday">Êú®</div>
            <div class="weekday">Èáë</div>
            <div class="weekday">Âúü</div>
            <!-- Days injected -->
        </div>

        <div class="board-view" id="boardView">
            <!-- Board injected -->
        </div>
    </main>

    <div class="modal-overlay" id="eventModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">‰∫àÂÆö„ÇíËøΩÂä†</h3>
                <button class="btn btn-icon-only" onclick="closeModal()"
                    style="border:none; background:none; font-size:1.5rem;">&times;</button>
            </div>
            <div class="form-group">
                <label>Á®ÆÂà•</label>
                <div class="category-selector" id="modalCategorySelector">
                    <!-- JS injected options -->
                </div>
            </div>
            <div class="form-group">
                <label>„Çø„Ç§„Éà„É´</label>
                <input type="text" id="eventTitle" placeholder="‰ºöË≠∞, Êâì„Å°Âêà„Çè„ÅõÁ≠â...">
            </div>
            <div class="form-group" style="display:grid; grid-template-columns: 1fr 1fr; gap:0.5rem;">
                <div>
                    <label>Êó•‰ªò</label>
                    <input type="date" id="eventDate">
                </div>
                <div>
                    <label>ÊôÇÈñì</label>
                    <input type="time" id="eventTime">
                </div>
            </div>
            <div class="form-group">
                <label>Ê∞èÂêç (Ë§áÊï∞ÈÅ∏ÊäûÂèØ)</label>
                <div class="writer-checkboxes" id="writerCheckboxes">
                    <!-- JS injected -->
                </div>
            </div>
            <div class="form-group">
                <label>Ë©≥Á¥∞ / „É°„É¢</label>
                <textarea id="eventDesc" rows="3" placeholder="Ë©≥Á¥∞„ÇíÂÖ•Âäõ..."></textarea>
            </div>
            <div class="form-group" style="display:flex; align-items:center;">
                <label style="margin-bottom:0; cursor:pointer; display:flex; align-items:center; gap:0.5rem;">
                    <input type="checkbox" id="eventCompleted" style="width:20px; height:20px;">
                    <span>ÂÆå‰∫Ü„Å®„Åó„Å¶„Éû„Éº„ÇØ</span>
                </label>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="deleteEvent()" id="btnDelete"
                    style="display:none; color: var(--danger-color); border-color:var(--danger-color);">ÂâäÈô§</button>
                <button class="btn" onclick="closeModal()">„Ç≠„É£„É≥„Çª„É´</button>
                <button class="btn primary" onclick="saveEvent()">‰øùÂ≠ò</button>
            </div>
        </div>
    </div>

    <!-- User Management Modal -->
    <div class="modal-overlay" id="userModal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">„É°„É≥„Éê„ÉºË®≠ÂÆö (ÊúÄÂ§ß99Âêç)</h3>
                <button class="btn btn-icon-only" onclick="closeUserModal()"
                    style="border:none; background:none; font-size:1.5rem;">&times;</button>
            </div>
            <div class="form-group">
                <div class="user-list" id="userListDisplay">
                    <!-- JS Injected -->
                </div>
            </div>
            <div class="form-group" style="display:flex; gap:0.5rem;">
                <input type="text" id="newUserName" placeholder="Êñ∞„Åó„ÅÑÊ∞èÂêç„ÇíÂÖ•Âäõ...">
                <button class="btn primary" onclick="addUser()">ËøΩÂä†</button>
            </div>

            <hr style="margin: 1.5rem 0; border: 0; border-top: 1px solid var(--border-color);">

            <div class="form-group">
                <h4 style="margin-bottom:0.5rem; font-size:1rem;">„Éó„É©„Ç§„Éô„Éº„Éà„Éá„Éº„ÇøÁÆ°ÁêÜ</h4>
                <div style="display:flex; gap:0.5rem;">
                    <button class="btn" onclick="exportPrivateData()">
                        üîí „Ç®„ÇØ„Çπ„Éù„Éº„Éà
                    </button>
                    <button class="btn" onclick="document.getElementById('importFile').click()">
                        üì• „Ç§„É≥„Éù„Éº„Éà
                    </button>
                    <input type="file" id="importFile" accept=".json" style="display:none;"
                        onchange="importPrivateData(this)">
                </div>
                <p style="font-size:0.75rem; color:var(--text-secondary); margin-top:0.5rem;">
                    „ÄåÁßò„Äç„Ç´„ÉÜ„Ç¥„É™„ÅÆ‰∫àÂÆö„ÅØ„Éñ„É©„Ç¶„Ç∂ÂÜÖ„Å´„ÅÆ„Åø‰øùÂ≠ò„Åï„Çå„Åæ„Åô„ÄÇÁ´ØÊú´ÁßªË°åÊôÇ„ÅØ„Ç®„ÇØ„Çπ„Éù„Éº„Éà/„Ç§„É≥„Éù„Éº„Éà„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
                </p>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const CATEGORIES = [
            { id: 'cat_zen', name: 'ÂÖ®', color: 'var(--cat-zen)' },
            { id: 'cat_sei', name: 'Êï¥', color: 'var(--cat-sei)' },
            { id: 'cat_toku', name: 'Áâπ', color: 'var(--cat-toku)' },
            { id: 'cat_cho', name: 'Ë™ø', color: 'var(--cat-cho)' },
            { id: 'cat_tou', name: 'ÂΩì', color: 'var(--cat-tou)' },
            { id: 'cat_kyu', name: '‰ºë', color: 'var(--cat-kyu)' },
            { id: 'cat_private', name: 'Áßò', color: 'var(--cat-private)', isPrivate: true },
        ];

        // --- State ---
        let state = {
            currentDate: new Date(),
            activeFilters: new Set(CATEGORIES.map(c => c.id)),
            users: [], // List of registered names
            events: [],
            viewMode: 'month', // 'month' or 'day'
            lastSelectedCategory: 'cat_zen',
            lastSelectedWriters: []
        };

        // --- Persistence Constants ---
        const PREF_LAST_CAT = 'lastSelectedCategory';
        const PREF_LAST_WRITERS = 'lastSelectedWriters';

        let fileHandle = null;
        let filePoller = null;
        let lastModifiedTime = 0;

        let editingEventId = null;

        // --- IndexedDB Manager ---
        const DB_NAME = 'TeamSyncDB';
        const STORE_NAME = 'prefs';
        const STORE_PRIVATE = 'private_events';
        let db = null;

        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 2);

                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                    if (!db.objectStoreNames.contains(STORE_PRIVATE)) {
                        db.createObjectStore(STORE_PRIVATE, { keyPath: 'id' });
                    }
                };

                request.onsuccess = (e) => {
                    db = e.target.result;
                    resolve(db);
                };

                request.onerror = (e) => reject(e);
            });
        }

        async function setPref(key, value) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                store.put(value, key);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject();
            });
        }

        async function getPref(key) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject();
            });
        }

        // --- Core Logic: Initialize ---

        async function init() {
            await initDB();

            // 1. Writer Name
            const search = window.location.search;
            let urlName = '';
            if (search) {
                if (search.startsWith("?name=")) urlName = decodeURIComponent(search.substring(6));
                else if (search.startsWith("?=")) urlName = decodeURIComponent(search.substring(2));
                else urlName = decodeURIComponent(search.substring(1));
            }

            if (urlName) {
                state.writerName = urlName;
                setPref('writerName', urlName);
            } else {
                const savedName = await getPref('writerName');
                if (savedName) state.writerName = savedName;
            }

            // 2. Filter Logic
            const savedFilters = await getPref('activeFilters');
            if (savedFilters && Array.isArray(savedFilters) && savedFilters.length > 0) {
                // Need to validate if saved filters exist in current CATEGORIES
                // If outdated IDs (like u1, cat_a) exist, they won't match, so fallback to all
                const validSaved = savedFilters.filter(id => CATEGORIES.some(c => c.id === id));
                if (validSaved.length > 0) {
                    state.activeFilters = new Set(validSaved);
                }
            }

            // 4. Persistence Load
            const savedLastCat = await getPref(PREF_LAST_CAT);
            if (savedLastCat) state.lastSelectedCategory = savedLastCat;

            const savedLastWriters = await getPref(PREF_LAST_WRITERS);
            if (savedLastWriters) state.lastSelectedWriters = savedLastWriters;

            // 5. Render
            renderFilters();
            renderModalSelector();
            renderCalendar();
            renderViewSwitcher();
        }

        // --- File System Access ---

        async function connectDatabase() {
            try {
                try {
                    [fileHandle] = await window.showOpenFilePicker({
                        types: [{ description: 'Scheduler Data JSON', accept: { 'application/json': ['.json'] } }],
                        multiple: false
                    });
                } catch (e) {
                    if (confirm("Êó¢Â≠ò„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÅãÔºüÊñ∞„Åó„ÅÑ„Éá„Éº„Çø„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê„Åó„Åæ„Åô„ÅãÔºü")) {
                        fileHandle = await window.showSaveFilePicker({
                            suggestedName: 'scheduler_data.json',
                            types: [{ description: 'Scheduler Data JSON', accept: { 'application/json': ['.json'] } }]
                        });
                        state.events = [];
                        await writeToFile(state.events);
                    } else {
                        return;
                    }
                }

                await loadFromFile();

                if (filePoller) clearInterval(filePoller);
                filePoller = setInterval(checkFileUpdates, 3000);

                document.getElementById('introBarrier').style.display = 'none';
                document.getElementById('mainContent').classList.add('active');
                document.getElementById('btnConnect').textContent = 'Êé•Á∂öÊ∏à„Åø: ' + fileHandle.name;
                document.getElementById('btnConnect').classList.add('success');
                document.getElementById('btnConnect').classList.remove('primary');
                updateStatus('Êé•Á∂öÂÆå‰∫Ü', 'connected');

            } catch (err) {
                console.error(err);
                if (err.name !== 'AbortError') alert('Êé•Á∂ö„Ç®„É©„Éº: ' + err.message);
            }
        }

        async function checkFileUpdates() {
            if (!fileHandle) return;
            try {
                const file = await fileHandle.getFile();
                if (file.lastModified > lastModifiedTime) {
                    updateStatus('ÂêåÊúü‰∏≠...', 'syncing');
                    const text = await file.text();
                    const json = JSON.parse(text);

                    if (json && json.events) {
                        state.events = json.events || [];
                        state.users = json.users || [];
                    } else {
                        // Fallback or init
                        state.events = [];
                        state.users = [];
                    }

                    lastModifiedTime = file.lastModified;
                    renderCalendar();
                    updateStatus('Êé•Á∂öÂÆå‰∫Ü', 'connected');
                }
            } catch (err) {
                console.warn("Polling error", err);
                updateStatus('ÂÜçÊé•Á∂ö‰∏≠...', 'syncing');
            }
        }

        async function loadFromFile() {
            const file = await fileHandle.getFile();
            const text = await file.text();
            lastModifiedTime = file.lastModified;

            if (text) {
                try {
                    const json = JSON.parse(text);
                    state.events = json.events || [];
                    state.users = json.users || [];
                } catch (e) {
                    console.error("JSON Parse Error", e);
                    state.events = [];
                    state.users = [];
                }
            } else {
                state.events = [];
                state.users = [];
            }

            // Merge Private Events
            const privateEvents = await getPrivateEvents();
            state.events = [...state.events, ...privateEvents];

            renderCalendar();
        }

        // --- Private Event Logic ---
        async function getPrivateEvents() {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_PRIVATE, 'readonly');
                const store = tx.objectStore(STORE_PRIVATE);
                const req = store.getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject([]);
            });
        }

        async function savePrivateEvent(evt) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_PRIVATE, 'readwrite');
                const store = tx.objectStore(STORE_PRIVATE);
                store.put(evt);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject();
            });
        }

        async function deletePrivateEvent(id) {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_PRIVATE, 'readwrite');
                const store = tx.objectStore(STORE_PRIVATE);
                store.delete(id);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject();
            });
        }

        async function writeToFile(events) {
            if (!fileHandle) return;
            try {
                updateStatus('‰øùÂ≠ò‰∏≠...', 'syncing');
                const writable = await fileHandle.createWritable();
                // Save as object { users, events }
                const data = {
                    users: state.users,
                    events: events
                };
                await writable.write(JSON.stringify(data, null, 2));
                await writable.close();

                const file = await fileHandle.getFile();
                lastModifiedTime = file.lastModified;

                updateStatus('‰øùÂ≠òÂÆå‰∫Ü', 'connected');
            } catch (err) {
                alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + err.message);
                updateStatus('‰øùÂ≠òÂ§±Êïó', 'dot');
            }
        }

        async function saveTransaction(actionCallback) {
            if (!fileHandle) return;
            try {
                const file = await fileHandle.getFile();
                const text = await file.text();
                let currentData = text ? JSON.parse(text) : { users: [], events: [] };

                // Ensure structure
                if (!currentData.users) currentData.users = [];
                if (!currentData.events) currentData.events = [];

                // Update events
                // actionCallback returns the NEW list of events. 
                // We need to differentiate: 
                // 1. The new event list contains mixed (Public + Private).
                // 2. We must split them. Public -> JSON, Private -> IndexedDB.

                // However, actionCallback logic acts on state.events.
                // To keep it simple, we don't pass `currentData.events` (file only) to callback.
                // We pass `state.events` (mixed).

                let allEvents = actionCallback(state.events);

                // Separation
                const publicEvents = allEvents.filter(e => !isPrivate(e));
                const privateEvents = allEvents.filter(e => isPrivate(e));

                // 1. Save Public to JSON
                await writeToFile(publicEvents); // writeToFile wraps in {users, events}

                // 2. Save Private to DB
                // We overwrite DB? Or sync? 
                // Simplest is to save individual private events or sync list.
                // Since we rely on ID, let's sync efficiently. 
                // Make sure we delete ones that are gone? 
                // For simplicity: clear and rewrite private store? Or just Put all.
                // Deleting removed private events is tricky if we just Put.

                // Better approach for Private: 
                // Since we just have a list, let's clear store and add all (inefficient but safe).
                await clearPrivateStore();
                for (const p of privateEvents) {
                    await savePrivateEvent(p);
                }

                state.events = allEvents;
                renderCalendar();
            } catch (err) {
                alert("Á´∂Âêà„ÅåÁô∫Áîü„Åó„Åü„Åã„ÄÅ„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶Ë©¶„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ" + err.message);
            }
        }

        function isPrivate(e) {
            const cat = CATEGORIES.find(c => c.id === (e.categoryId || e.userId));
            return cat && cat.isPrivate;
        }

        async function clearPrivateStore() {
            if (!db) await initDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_PRIVATE, 'readwrite');
                const store = tx.objectStore(STORE_PRIVATE);
                store.clear();
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject();
            });
        }

        // --- UI Helpers ---

        function updateStatus(text, dotClass) {
            document.getElementById('statusText').textContent = text;
            document.getElementById('statusDot').className = 'dot ' + dotClass;
        }

        function renderFilters() {
            const container = document.getElementById('filterGroup');
            const btnsHtml = CATEGORIES.map(cat => `
            <div class="filter-btn ${state.activeFilters.has(cat.id) ? 'active' : ''}" 
                 style="background: ${cat.color}" 
                 onclick="toggleFilter('${cat.id}')"
                 title="${cat.name}„ÇíË°®Á§∫/ÈùûË°®Á§∫">
                ${cat.name}
            </div>
        `).join('');
            container.innerHTML = `<span class="filter-label">Ë°®Á§∫:</span>` + btnsHtml;
        }

        function toggleFilter(catId) {
            if (state.activeFilters.has(catId)) {
                state.activeFilters.delete(catId);
            } else {
                state.activeFilters.add(catId);
            }

            setPref('activeFilters', Array.from(state.activeFilters));
            renderFilters();
            renderCalendar();
        }

        function renderModalSelector() {
            const container = document.getElementById('modalCategorySelector');
            container.innerHTML = CATEGORIES.map((cat, idx) => `
            <label class="radio-option">
                <input type="radio" name="category" value="${cat.id}" ${idx === 0 ? 'checked' : ''}>
                <div class="radio-circle" style="border-color: ${cat.color}; background: ${cat.color}20"></div>
                ${cat.name}
            </label>
        `).join('');
        }

        function switchView(mode) {
            state.viewMode = mode;
            renderViewSwitcher();
            renderCalendar(); // Renders appropriate view
        }

        function renderViewSwitcher() {
            document.getElementById('btnViewMonth').className = `view-btn ${state.viewMode === 'month' ? 'active' : ''}`;
            document.getElementById('btnViewDay').className = `view-btn ${state.viewMode === 'day' ? 'active' : ''}`;
        }

        function navigateDate(delta) {
            if (state.viewMode === 'month') {
                state.currentDate.setMonth(state.currentDate.getMonth() + delta);
            } else {
                state.currentDate.setDate(state.currentDate.getDate() + delta);
            }
            renderCalendar();
        }

        function renderCalendar() {
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            const date = state.currentDate.getDate();

            if (state.viewMode === 'month') {
                document.getElementById('calendarGrid').style.display = 'grid';
                document.getElementById('boardView').classList.remove('active');
                document.getElementById('monthLabel').textContent = `${year}Âπ¥ ${month + 1}Êúà`;
                renderMonthView();
            } else {
                document.getElementById('calendarGrid').style.display = 'none';
                document.getElementById('boardView').classList.add('active');
                document.getElementById('monthLabel').textContent = `${year}Âπ¥ ${month + 1}Êúà ${date}Êó•`;
                renderBoardView();
            }
        }

        function renderMonthView() {
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDayIndex = firstDay.getDay();
            const totalDays = lastDay.getDate();
            const grid = document.getElementById('calendarGrid');
            const headers = Array.from(grid.children).slice(0, 7);
            grid.innerHTML = '';
            headers.forEach(h => grid.appendChild(h));
            const prevMonthLastDay = new Date(year, month, 0).getDate();
            for (let i = startDayIndex - 1; i >= 0; i--) {
                grid.innerHTML += createDayHTML(prevMonthLastDay - i, true);
            }
            const today = new Date();
            for (let i = 1; i <= totalDays; i++) {
                const isToday = i === today.getDate() && month === today.getMonth() && year === today.getFullYear();
                const dayDateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                grid.innerHTML += createDayHTML(i, false, isToday, dayDateStr);
            }
            const remaining = 42 - (startDayIndex + totalDays);
            for (let i = 1; i <= remaining; i++) {
                grid.innerHTML += createDayHTML(i, true);
            }
        }

        function renderBoardView() {
            const container = document.getElementById('boardView');
            const year = state.currentDate.getFullYear();
            const month = state.currentDate.getMonth();
            const day = state.currentDate.getDate();
            const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

            // Get events for today, filtered
            const dayEvents = state.events.filter(e => {
                let catId = resolveCategoryId(e);
                return e.date === dateStr && state.activeFilters.has(catId);
            });
            dayEvents.sort((a, b) => a.time.localeCompare(b.time));

            // Group by User
            // Events can have multiple writers (e.writers) or single (e.writer)
            // If e.writers has ['A', 'B'], show in both A and B rows.
            // If empty, show in Unassigned.

            const userMap = new Map();
            state.users.forEach(u => userMap.set(u, []));
            const unassigned = [];

            dayEvents.forEach(e => {
                let assigned = false;
                const writers = e.writers || (e.writer ? [e.writer] : []);
                if (writers.length > 0) {
                    writers.forEach(w => {
                        if (userMap.has(w)) {
                            userMap.get(w).push(e);
                            assigned = true;
                        }
                    });
                    // If writers exist but not in registry (deleted users), treat as unassigned or legacy? 
                    // Let's assume legacy names just don't appear in rows unless we add 'Others'.
                    // For now, only registered users get rows.
                }
                if (!assigned && writers.length === 0) {
                    unassigned.push(e);
                }
            });

            let html = '';

            // Render User Rows
            state.users.forEach(u => {
                const events = userMap.get(u);
                const eventHtml = events.map(e => createEventChip(e, true)).join('');
                html += `
                <div class="board-row">
                    <div class="board-user-label">${escapeHtml(u)}</div>
                    <div class="board-timeline" onclick="openAddModal('${dateStr}', ['${escapeHtml(u)}'])">
                        ${eventHtml}
                    </div>
                </div>`;
            });

            // Render Unassigned
            if (unassigned.length > 0) {
                const eventHtml = unassigned.map(e => createEventChip(e, true)).join('');
                html += `
                <div class="board-row">
                    <div class="board-user-label" style="font-style:italic;">Êú™Ââ≤„ÇäÂΩì„Å¶</div>
                    <div class="board-timeline" onclick="openAddModal('${dateStr}')">
                        ${eventHtml}
                    </div>
                </div>`;
            } else if (state.users.length === 0) {
                html = `<div style="padding:2rem; text-align:center; color:#aaa;">„É°„É≥„Éê„Éº„ÅåÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ<br>„Äå„É°„É≥„Éê„ÉºË®≠ÂÆö„Äç„Åã„ÇâËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</div>`;
            }

            container.innerHTML = html;
        }

        // Refactored Event Chip Creation
        function createEventChip(e, showTime = false) {
            let catId = resolveCategoryId(e);
            const cat = CATEGORIES.find(c => c.id === catId) || CATEGORIES[0];
            let writersStr = '';

            if (e.writers && Array.isArray(e.writers)) writersStr = e.writers.join(', ');

            const writerHtml = (writersStr && !showTime) ? `<span class="event-writer">${escapeHtml(writersStr)}</span>` : '';
            const completedClass = e.completed ? 'completed' : '';

            return `
                <div class="event-chip ${completedClass}" 
                        data-category="${cat.id}"
                        style="background: ${cat.color}"
                        onclick="openEditModal('${e.id}', event)">
                        <span style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                        ${e.time} ${escapeHtml(e.title)}
                        </span>
                        ${writerHtml}
                </div>
            `;
        }

        function createDayHTML(dayNum, isGrey, isToday = false, dateStr = '') {
            let eventsHTML = '';

            if (!isGrey && dateStr) {
                const dayEvents = state.events.filter(e => {
                    let catId = resolveCategoryId(e);
                    return e.date === dateStr && state.activeFilters.has(catId);
                });

                dayEvents.sort((a, b) => a.time.localeCompare(b.time));

                dayEvents.forEach(e => {
                    eventsHTML += createEventChip(e);
                });
            }

            return `
            <div class="day-cell ${isGrey ? 'other-month' : ''} ${isToday ? 'today' : ''}"
                 ${!isGrey ? `onclick="openAddModal('${dateStr}')"` : ''}>
                <div class="day-number">${dayNum}</div>
                <div class="events-stack">${eventsHTML}</div>
            </div>
        `;
        }

        // Helper to map old IDs to new ones
        function resolveCategoryId(evt) {
            let raw = evt.categoryId || evt.userId;

            // If it's a valid ID, return it
            if (CATEGORIES.some(c => c.id === raw)) return raw;

            // Fallback
            return 'cat_zen';
        }

        // --- Modal Actions ---

        function openAddModal(dateStr, preselectedWriters = []) {
            if (!fileHandle) { alert("„Åæ„Åö„ÅØ„Äå„Éá„Éº„Çø„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Äç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"); return; }

            editingEventId = null;
            document.getElementById('modalTitle').textContent = '‰∫àÂÆö„ÇíËøΩÂä†';
            document.getElementById('eventTitle').value = '';
            document.getElementById('eventDate').value = dateStr;
            document.getElementById('eventTime').value = '';
            document.getElementById('eventDesc').value = '';
            document.getElementById('eventCompleted').checked = false;

            // Logic for default writers:
            // 1. If preselected (from board view click), use those.
            // 2. Else use Saved Preferences.
            let defaults = [];
            if (preselectedWriters.length > 0) {
                defaults = preselectedWriters;
            } else {
                defaults = state.lastSelectedWriters || [];
            }
            renderWriterCheckboxes(defaults);

            // Logic for default category
            const defCat = state.lastSelectedCategory || 'cat_zen';
            const radio = document.querySelector(`input[name="category"][value="${defCat}"]`);
            if (radio) radio.checked = true;

            document.getElementById('btnDelete').style.display = 'none';
            document.getElementById('eventModal').classList.add('open');
            setTimeout(() => document.getElementById('eventTitle').focus(), 100);
        }

        function openEditModal(evtId, e) {
            e.stopPropagation();
            const evt = state.events.find(x => x.id === evtId);
            if (!evt) return;

            editingEventId = evtId;
            document.getElementById('modalTitle').textContent = '‰∫àÂÆö„ÇíÁ∑®ÈõÜ';
            document.getElementById('eventTitle').value = evt.title;
            document.getElementById('eventDate').value = evt.date;
            document.getElementById('eventTime').value = evt.time;
            document.getElementById('eventDesc').value = evt.desc;
            document.getElementById('eventCompleted').checked = !!evt.completed;

            // Checkboxes
            const currentWriters = evt.writers || (evt.writer ? [evt.writer] : []);
            renderWriterCheckboxes(currentWriters);

            const catId = resolveCategoryId(evt);
            const radio = document.querySelector(`input[name="category"][value="${catId}"]`) || document.querySelector('input[name="category"][value="cat_zen"]');
            if (radio) radio.checked = true;

            document.getElementById('btnDelete').style.display = 'block';
            document.getElementById('eventModal').classList.add('open');
        }

        function closeModal() {
            document.getElementById('eventModal').classList.remove('open');
        }

        async function saveEvent() {
            const title = document.getElementById('eventTitle').value;
            const date = document.getElementById('eventDate').value;
            const time = document.getElementById('eventTime').value;
            const desc = document.getElementById('eventDesc').value;
            const completed = document.getElementById('eventCompleted').checked;

            // Collect writers
            const checkboxes = document.querySelectorAll('#writerCheckboxes input:checked');
            const writers = Array.from(checkboxes).map(cb => cb.value);

            const categoryId = document.querySelector('input[name="category"]:checked').value;

            if (!title || !date) { alert('ÂøÖÈ†àÈ†ÖÁõÆ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì'); return; }

            // Save Preferences
            setPref(PREF_LAST_CAT, categoryId);
            state.lastSelectedCategory = categoryId;
            setPref(PREF_LAST_WRITERS, writers);
            state.lastSelectedWriters = writers;

            closeModal();

            await saveTransaction((events) => {
                const eventData = {
                    title, date, time, desc, writers, categoryId, completed
                };

                if (editingEventId) {
                    // Update
                    return events.map(e => e.id === editingEventId ? {
                        ...e, ...eventData, updatedAt: Date.now()
                    } : e);
                } else {
                    // Create
                    const newEvent = {
                        id: Date.now().toString(36) + Math.random().toString(36).substr(2),
                        ...eventData,
                        createdAt: Date.now()
                    };
                    return [...events, newEvent];
                }
            });
        }

        // --- User Management Logic ---
        function openUserModal() {
            renderUserList();
            document.getElementById('userModal').classList.add('open');
            setTimeout(() => document.getElementById('newUserName').focus(), 100);
        }

        function closeUserModal() {
            document.getElementById('userModal').classList.remove('open');
        }

        function renderUserList() {
            const container = document.getElementById('userListDisplay');
            container.innerHTML = state.users.map((name, idx) => `
                <div class="user-chip">
                    <span style="flex:1;">${escapeHtml(name)}</span>
                    <div style="display:flex; gap:2px; margin-right:8px;">
                        <button class="btn btn-icon-only" style="padding:2px; width:20px; height:20px; font-size:0.6rem;" onclick="moveUser(${idx}, -1)" ${idx === 0 ? 'disabled' : ''}>‚ñ≤</button>
                        <button class="btn btn-icon-only" style="padding:2px; width:20px; height:20px; font-size:0.6rem;" onclick="moveUser(${idx}, 1)" ${idx === state.users.length - 1 ? 'disabled' : ''}>‚ñº</button>
                    </div>
                    <span class="delete-btn" onclick="deleteUser(${idx})">&times;</span>
                </div>
             `).join('');
        }

        async function moveUser(idx, direction) {
            const newIdx = idx + direction;
            if (newIdx < 0 || newIdx >= state.users.length) return;

            // Swap
            const temp = state.users[idx];
            state.users[idx] = state.users[newIdx];
            state.users[newIdx] = temp;

            renderUserList();

            // Save immediately
            if (fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    let json = text ? JSON.parse(text) : { users: [], events: [] };

                    // Keep events, update users
                    if (json && json.events) {
                        json.users = state.users;
                    } else {
                        // Fallback
                        json = { users: state.users, events: [] };
                    }

                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(json, null, 2));
                    await writable.close();
                } catch (e) {
                    console.error(e);
                    alert('‰øùÂ≠ò„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü');
                }
            }
        }

        async function exportPrivateData() {
            const privateEvents = await getPrivateEvents();
            if (privateEvents.length === 0) {
                alert('„Éó„É©„Ç§„Éô„Éº„Éà„Å™‰∫àÂÆö„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ');
                return;
            }

            const blob = new Blob([JSON.stringify(privateEvents, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `private_backup_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function importPrivateData(input) {
            const file = input.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const json = JSON.parse(text);

                if (!Array.isArray(json)) {
                    alert('ÁÑ°Âäπ„Å™„Éï„Ç°„Ç§„É´ÂΩ¢Âºè„Åß„Åô„ÄÇÈÖçÂàóÂΩ¢Âºè„ÅÆJSON„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    return;
                }

                if (!confirm(`„Ç§„É≥„Éù„Éº„Éà„Åô„Çã„Å®ÁèæÂú®„ÅÆ„Éó„É©„Ç§„Éô„Éº„Éà‰∫àÂÆö„Å´ËøΩÂä†„Éª‰∏äÊõ∏„Åç„Åï„Çå„Åæ„Åô„ÄÇ\n(${json.length}‰ª∂)`)) {
                    input.value = '';
                    return;
                }

                // Merge import
                await clearPrivateStore(); // Optional: Clear or Append? User asked for migration support implies replace or merge. 
                // Usually restore = replace or smart merge. 
                // Let's go with "Merge/Overwrite by ID".

                // Better strategy: Keep existing, add imported.
                // But if ID collision? Overwrite.

                // Wait, logic above was "clearPrivateStore" then loop. 
                // If I want to KEEP existing, I should read them first? 
                // Implementation Plan said: "Load JSON and overwrite/merge".

                // Let's do simple PUT loop.
                for (const evt of json) {
                    // Ensure it is marked private
                    // (Though if imported from private backup it should be)
                    // Just in case, force category logic compliance? 
                    // No, evt should have categoryId = 'cat_private'

                    if (evt.categoryId === 'cat_private') {
                        await savePrivateEvent(evt);
                    }
                }

                // Reload
                state.events = [...(state.events.filter(e => !isPrivate(e))), ...json.filter(e => isPrivate(e))];
                // Actually we should reload full state properly
                const privateEvents = await getPrivateEvents(); // Real source of truth
                // We need to re-read public events too? 
                // state.events currently has mixed. 
                // Let's allow simple refresh:

                const publicEvents = state.events.filter(e => !isPrivate(e));
                state.events = [...publicEvents, ...privateEvents];

                renderCalendar();
                alert('„Ç§„É≥„Éù„Éº„ÉàÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ');

            } catch (e) {
                console.error(e);
                alert('„Ç§„É≥„Éù„Éº„Éà„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + e.message);
            }
            input.value = '';
        }

        async function addUser() {
            const input = document.getElementById('newUserName');
            const name = input.value.trim();
            if (!name) return;

            if (state.users.length >= 99) {
                alert('ÁôªÈå≤‰∫∫Êï∞„Åå‰∏äÈôê(99‰∫∫)„Å´ÈÅî„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ');
                return;
            }
            if (state.users.includes(name)) {
                alert('Êó¢„Å´ÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ');
                return;
            }

            state.users.push(name);
            input.value = '';
            renderUserList();

            // Save immediately
            if (fileHandle) {
                // For user updates, we re-read file to avoid event overwrites, 
                // but simpler to just write full object with current events.
                try {
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    let json = text ? JSON.parse(text) : { users: [], events: [] };
                    if (Array.isArray(json)) json = { users: [], events: json };

                    json.users = state.users;

                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(json, null, 2));
                    await writable.close();
                } catch (e) {
                    console.error(e);
                    alert('‰øùÂ≠ò„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü');
                }
            }
        }

        async function deleteUser(idx) {
            if (!confirm('„Åì„ÅÆ„É°„É≥„Éê„Éº„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
            state.users.splice(idx, 1);
            renderUserList();
            // Save immediately
            if (fileHandle) {
                try {
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    let json = text ? JSON.parse(text) : { users: [], events: [] };
                    if (Array.isArray(json)) json = { users: [], events: json };

                    json.users = state.users;

                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(json, null, 2));
                    await writable.close();
                } catch (e) {
                    console.error(e);
                }
            }
        }

        function renderWriterCheckboxes(selectedWriters) {
            const container = document.getElementById('writerCheckboxes');
            if (state.users.length === 0) {
                container.innerHTML = '<span style="color:#aaa; font-size:0.8rem;">„É°„É≥„Éê„Éº„ÅåÁôªÈå≤„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ<br>„Äå„É°„É≥„Éê„ÉºË®≠ÂÆö„Äç„Åã„ÇâËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</span>';
                return;
            }

            container.innerHTML = state.users.map(u => {
                const isChecked = selectedWriters.includes(u);
                return `
                <label class="writer-option">
                    <input type="checkbox" value="${escapeHtml(u)}" ${isChecked ? 'checked' : ''}>
                    ${escapeHtml(u)}
                </label>
            `;
            }).join('');
        }

        async function deleteEvent() {
            if (!confirm('ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
            closeModal();
            await saveTransaction((events) => {
                return events.filter(e => e.id !== editingEventId);
            });
        }

        function changeMonth(delta) {
            state.currentDate.setMonth(state.currentDate.getMonth() + delta);
            renderCalendar();
        }

        function goToToday() {
            state.currentDate = new Date();
            renderCalendar();
        }

        function escapeHtml(text) {
            if (!text) return '';
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        // Boot
        init();

    </script>
</body>

</html>